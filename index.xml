<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Kubernetes Introduction</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/</link><description>Recent content in Home on Kubernetes Introduction</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 20 Apr 2022 09:32:49 +0200</lastBuildDate><atom:link href="https://lukaspj.github.io/VIA-Kubernetes-Introduction/index.xml" rel="self" type="application/rss+xml"/><item><title>Installation</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/setup/</link><pubDate>Wed, 20 Apr 2022 09:33:09 +0200</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/setup/</guid><description>We will use Docker For Desktop which is free for smaller companies and costs a small fee per developer for large companies. It supports both Mac and Windows.
Install Docker For Desktop on Mac Install Docker For Desktop on Windows Verify that Docker is working by running the following command: docker ps
And then enable Kubernetes.
Verify that everything is set up and running by running the following command in a terminal and check that you get a similar output:</description></item><item><title>Containers</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/containers/</link><pubDate>Thu, 21 Apr 2022 12:25:57 +0200</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/containers/</guid><description>A container is an &amp;ldquo;isolated process&amp;rdquo;, it&amp;rsquo;s easiest to just think of it as a VM.1 The benefits of containers is that you have a self-contained run-time environment that describes how to run your application.
For example, let&amp;rsquo;s say I had written a Java server application, and I hand it off to you and say &amp;ldquo;run it&amp;rdquo;. What are you supposed to do with it? First, you need to figure out which version of Java it needs, then you need to know if it requires a configuration file, is it supposed to run inside TomCat or as a stand-alone server?</description></item><item><title>Pods</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/pod/</link><pubDate>Fri, 22 Apr 2022 14:02:36 +0200</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/pod/</guid><description>In Kubernetes, a &amp;ldquo;Pod&amp;rdquo;1 is the smallest deployable unit possible. This is kind of an abstract description. It&amp;rsquo;s easiest to think of as a pod = a container. In advanced Kubernetes usage, this is not always true, but for now it is enough.
All Kubernetes deployments are described using a generic YAML format, which can be quite verbose.
Here is a YAML for creating a pod using our Docker image:</description></item><item><title>Deployment</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/deployment/</link><pubDate>Fri, 22 Apr 2022 14:02:45 +0200</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/deployment/</guid><description>Creating a pod is cool, but it&amp;rsquo;s not that different from just running the Docker container pod by hand. Let&amp;rsquo;s try doing something slightly more sophisticated.
We&amp;rsquo;ll create a Deployment1 which is a &amp;ldquo;controller&amp;rdquo; that manages your pods.
It follows the same basic structure as the Pod YAML but its spec is significantly more complicated:
apiVersion:apps/v1kind:Deploymentmetadata:name:pythonapp-deploymentspec:selector:matchLabels:app:pythonapptemplate:metadata:labels:app:pythonappspec:containers:- name:pythonappimage:pythonappimagePullPolicy:NeverSo let&amp;rsquo;s look into the spec first we have a selector which describes how the deployment identifies its pods.</description></item><item><title>Service</title><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/service/</link><pubDate>Fri, 22 Apr 2022 14:02:53 +0200</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/service/</guid><description>In Kubernetes the term &amp;ldquo;Service&amp;rdquo;1 is used for loadbalancers inside the cluster. In this section, we will explore how to communicate with multiple pods using these loadbalancers so you can communicate with any of pods through a single interface.
To begin with, modify your Python application:
import signalimport socketimport sysfrom flask import Flaskapp = Flask(__name__)@app.route(&amp;#34;/&amp;#34;)def hello():return f&amp;#34;Hello World! My name is {socket.gethostname()}&amp;#34;def terminate(signal, frame):sys.exit(0)if __name__ == &amp;#34;__main__&amp;#34;:# Workaround for Flask not always respecting sigtermsignal.</description></item><item><title/><link>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/configure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lukaspj.github.io/VIA-Kubernetes-Introduction/guide/configure/</guid><description/></item></channel></rss>